
import { supabase } from '@/integrations/supabase/client';
import { DiaryEntryWithAuthor } from '@/types/diary';
import { filterEntriesBySearchTerm } from './utils/diaryFilters';

export const fetchUserDiaryEntries = async (
  effectiveUserId: string,
  searchTerm: string,
  startDate: string,
  endDate: string
): Promise<DiaryEntryWithAuthor[]> => {
  console.log('üîç Diary - R√©cup√©ration des entr√©es pour utilisateur:', effectiveUserId);
  
  // 1. R√©cup√©rer les entr√©es de l'utilisateur effectif
  let userEntriesQuery = supabase
    .from('diary_entries')
    .select('*')
    .eq('user_id', effectiveUserId)
    .order('entry_date', { ascending: false });

  // Appliquer les filtres de date
  if (startDate) {
    userEntriesQuery = userEntriesQuery.gte('entry_date', startDate);
  }
  if (endDate) {
    userEntriesQuery = userEntriesQuery.lte('entry_date', endDate);
  }

  const { data: userEntries, error: userEntriesError } = await userEntriesQuery;
  
  if (userEntriesError) {
    console.error('üîç Diary - Erreur lors de la r√©cup√©ration des entr√©es utilisateur:', userEntriesError);
    return [];
  }

  console.log('üîç Diary - Entr√©es utilisateur trouv√©es:', { 
    count: userEntries?.length || 0
  });

  // 2. R√©cup√©rer les utilisateurs autoris√©s via les permissions directes
  console.log('üîç Diary - V√©rification des permissions directes pour:', effectiveUserId);
  const { data: directPermissions, error: directPermError } = await supabase
    .from('diary_permissions')
    .select('diary_owner_id')
    .eq('permitted_user_id', effectiveUserId);

  if (directPermError) {
    console.error('üîç Diary - Erreur permissions directes:', directPermError);
  }

  const directAuthorizedIds = directPermissions?.map(p => p.diary_owner_id) || [];
  console.log('üîç Diary - Permissions directes trouv√©es:', directAuthorizedIds);

  // 3. APPROCHE SIMPLIFI√âE : R√©cup√©rer les groupes √©tape par √©tape
  console.log('üîç Diary - √âTAPE 1: R√©cup√©ration des memberships de groupe');
  
  // D'abord r√©cup√©rer les memberships de l'utilisateur
  const { data: userMemberships, error: membershipsError } = await supabase
    .from('group_members')
    .select('group_id, role')
    .eq('user_id', effectiveUserId)
    .eq('role', 'guest');

  if (membershipsError) {
    console.error('üîç Diary - Erreur memberships:', membershipsError);
  }

  console.log('üîç Diary - Memberships trouv√©s:', {
    count: userMemberships?.length || 0,
    memberships: userMemberships?.map(m => ({ group_id: m.group_id, role: m.role }))
  });

  let invitationAuthorizedIds: string[] = [];

  if (userMemberships && userMemberships.length > 0) {
    console.log('üîç Diary - √âTAPE 2: R√©cup√©ration des d√©tails des groupes');
    
    // CORRECTION: R√©cup√©rer les d√©tails des groupes avec une approche plus simple
    const groupIds = userMemberships.map(m => m.group_id);
    console.log('üîç Diary - Group IDs √† rechercher:', groupIds);
    
    const { data: groupDetails, error: groupDetailsError } = await supabase
      .from('invitation_groups')
      .select('id, created_by, name')
      .in('id', groupIds);

    if (groupDetailsError) {
      console.error('üîç Diary - Erreur d√©tails groupes:', groupDetailsError);
      console.error('üîç Diary - D√©tails de l\'erreur:', {
        message: groupDetailsError.message,
        details: groupDetailsError.details,
        hint: groupDetailsError.hint,
        code: groupDetailsError.code
      });
    } else {
      console.log('üîç Diary - D√©tails des groupes r√©cup√©r√©s avec succ√®s:', {
        count: groupDetails?.length || 0,
        groups: groupDetails?.map(g => ({ id: g.id, created_by: g.created_by, name: g.name }))
      });
    }

    if (groupDetails && groupDetails.length > 0) {
      console.log('üîç Diary - √âTAPE 3: V√©rification des invitations avec acc√®s journal');
      
      // Pour chaque groupe, v√©rifier les invitations avec diary_access
      for (const group of groupDetails) {
        console.log(`üîç Diary - V√©rification du groupe ${group.id} cr√©√© par ${group.created_by}`);
        
        const { data: groupInvitations, error: invitationsError } = await supabase
          .from('invitations')
          .select('id, invited_by, email, diary_access, used_at')
          .eq('group_id', group.id)
          .eq('diary_access', true)
          .not('used_at', 'is', null);

        if (invitationsError) {
          console.error(`üîç Diary - Erreur invitations pour groupe ${group.id}:`, invitationsError);
          continue;
        }

        console.log(`üîç Diary - Invitations avec acc√®s journal pour groupe ${group.id}:`, {
          count: groupInvitations?.length || 0,
          invitations: groupInvitations?.map(inv => ({
            id: inv.id,
            invited_by: inv.invited_by,
            email: inv.email,
            diary_access: inv.diary_access,
            used_at: inv.used_at
          }))
        });

        // Si des invitations avec acc√®s journal existent, ajouter le cr√©ateur du groupe
        if (groupInvitations && groupInvitations.length > 0) {
          const hasValidInvitation = groupInvitations.some(inv => 
            inv.diary_access === true && inv.used_at !== null
          );
          
          if (hasValidInvitation) {
            console.log(`üîç Diary - ‚úÖ Invitation valide trouv√©e - Ajout du cr√©ateur ${group.created_by}`);
            invitationAuthorizedIds.push(group.created_by);
          } else {
            console.log(`üîç Diary - ‚ùå Aucune invitation valide trouv√©e pour le groupe ${group.id}`);
          }
        } else {
          console.log(`üîç Diary - ‚ùå Aucune invitation avec acc√®s journal pour le groupe ${group.id}`);
        }
      }
    } else {
      console.log('üîç Diary - ‚ùå Aucun d√©tail de groupe r√©cup√©r√© - V√©rification directe des invitations');
      
      // Si la r√©cup√©ration des groupes √©choue, essayer une approche directe
      // R√©cup√©rer directement les invitations pour les groupes de l'utilisateur
      for (const membership of userMemberships) {
        console.log(`üîç Diary - V√©rification directe des invitations pour le groupe ${membership.group_id}`);
        
        const { data: directInvitations, error: directInvError } = await supabase
          .from('invitations')
          .select('invited_by, diary_access, used_at')
          .eq('group_id', membership.group_id)
          .eq('diary_access', true)
          .not('used_at', 'is', null);

        if (directInvError) {
          console.error(`üîç Diary - Erreur invitations directes pour groupe ${membership.group_id}:`, directInvError);
          continue;
        }

        console.log(`üîç Diary - Invitations directes trouv√©es pour groupe ${membership.group_id}:`, {
          count: directInvitations?.length || 0,
          invitations: directInvitations
        });

        if (directInvitations && directInvitations.length > 0) {
          // Ajouter les cr√©ateurs des invitations (invited_by)
          const creators = directInvitations.map(inv => inv.invited_by);
          invitationAuthorizedIds.push(...creators);
          console.log(`üîç Diary - ‚úÖ Ajout des cr√©ateurs d'invitations: ${creators.join(', ')}`);
        }
      }
    }
  } else {
    console.log('üîç Diary - ‚ùå Aucun membership de groupe trouv√© pour l\'utilisateur');
  }

  // D√©duplication des IDs autoris√©s via invitations
  invitationAuthorizedIds = [...new Set(invitationAuthorizedIds)];
  console.log('üîç Diary - IDs autoris√©s via invitations (d√©dupliqu√©s):', invitationAuthorizedIds);

  // 4. Combiner tous les IDs autoris√©s (sauf l'utilisateur effectif lui-m√™me)
  const allAuthorizedIds = [...new Set([...directAuthorizedIds, ...invitationAuthorizedIds])]
    .filter(id => id !== effectiveUserId);
  
  console.log('üîç Diary - R√âSULTAT FINAL - Tous les utilisateurs autoris√©s:', {
    directPermissions: directAuthorizedIds,
    invitationPermissions: invitationAuthorizedIds,
    combined: allAuthorizedIds,
    effectiveUserId: effectiveUserId
  });

  let otherEntries: any[] = [];

  // 5. R√©cup√©rer les entr√©es des autres utilisateurs autoris√©s
  if (allAuthorizedIds.length > 0) {
    console.log('üîç Diary - R√©cup√©ration des entr√©es des utilisateurs autoris√©s:', allAuthorizedIds);
    
    // CORRECTION: V√©rifier d'abord combien d'entr√©es existent pour ces utilisateurs
    const { data: countCheck, error: countError } = await supabase
      .from('diary_entries')
      .select('user_id, id, title, entry_date')
      .in('user_id', allAuthorizedIds);

    if (countError) {
      console.error('üîç Diary - Erreur lors de la v√©rification du nombre d\'entr√©es:', countError);
    } else {
      console.log('üîç Diary - V√©rification des entr√©es existantes:', {
        totalEntries: countCheck?.length || 0,
        entriesByUser: countCheck?.reduce((acc, entry) => {
          acc[entry.user_id] = (acc[entry.user_id] || 0) + 1;
          return acc;
        }, {} as Record<string, number>) || {},
        sampleEntries: countCheck?.slice(0, 3).map(e => ({
          user_id: e.user_id,
          id: e.id,
          title: e.title,
          entry_date: e.entry_date
        })) || []
      });
    }
    
    let otherEntriesQuery = supabase
      .from('diary_entries')
      .select('*')
      .in('user_id', allAuthorizedIds)
      .order('entry_date', { ascending: false });

    // Appliquer les filtres de date
    if (startDate) {
      otherEntriesQuery = otherEntriesQuery.gte('entry_date', startDate);
    }
    if (endDate) {
      otherEntriesQuery = otherEntriesQuery.lte('entry_date', endDate);
    }

    const { data: otherEntriesData, error: otherEntriesError } = await otherEntriesQuery;
    
    if (otherEntriesError) {
      console.error('üîç Diary - Erreur lors de la r√©cup√©ration des autres entr√©es:', otherEntriesError);
    } else {
      otherEntries = otherEntriesData || [];
      console.log('üîç Diary - Autres entr√©es trouv√©es:', { 
        count: otherEntries.length,
        fromUsers: [...new Set(otherEntries.map(e => e.user_id))],
        entriesByUser: otherEntries.reduce((acc, entry) => {
          const userId = entry.user_id;
          acc[userId] = (acc[userId] || []).concat([{ id: entry.id, title: entry.title }]);
          return acc;
        }, {} as Record<string, any[]>)
      });
    }
  } else {
    console.log('üîç Diary - Aucun autre utilisateur autoris√© trouv√©');
  }

  // 6. Combiner toutes les entr√©es
  const allEntries = [...(userEntries || []), ...otherEntries];
  console.log('üîç Diary - Total entr√©es combin√©es:', {
    userEntriesCount: userEntries?.length || 0,
    otherEntriesCount: otherEntries.length,
    totalCount: allEntries.length
  });
  
  // 7. Trier par date d'entr√©e (plus r√©cent en premier)
  allEntries.sort((a, b) => new Date(b.entry_date).getTime() - new Date(a.entry_date).getTime());

  // 8. R√©cup√©rer tous les profils n√©cessaires
  const allUserIds = [...new Set(allEntries.map(entry => entry.user_id))];
  const { data: allProfiles } = await supabase
    .from('profiles')
    .select('id, email, display_name, avatar_url, created_at')
    .in('id', allUserIds);

  // 9. Filtrage c√¥t√© client pour le terme de recherche
  const finalEntries = filterEntriesBySearchTerm(allEntries, searchTerm, allProfiles || []);
  
  console.log('üîç Diary - Entr√©es finales apr√®s filtrage:', {
    totalCount: finalEntries.length,
    searchTerm: searchTerm,
    entriesByUser: finalEntries.reduce((acc, entry) => {
      const userId = entry.user_id;
      acc[userId] = (acc[userId] || 0) + 1;
      return acc;
    }, {} as Record<string, number>)
  });
  
  return finalEntries;
};
