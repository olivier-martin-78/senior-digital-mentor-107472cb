// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://cvcebcisijjmmmwuedcv.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN2Y2ViY2lzaWpqbW1td3VlZGN2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDcxNTE5MTEsImV4cCI6MjA2MjcyNzkxMX0.ajg0CHVdVC6QenC9CVDN_5vikA6-JoUxXeX3yz64AUE";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Enhanced mobile detection with fallbacks
const detectMobilePlatform = () => {
  if (typeof navigator === 'undefined') return false;
  
  // First check common mobile platforms
  const isMobileDevice = /iPhone|iPad|iPod|Android|webOS|BlackBerry|Windows Phone|Opera Mini|Mobile|Tablet/i.test(navigator.userAgent);
  
  // Second check for touch capability as a fallback
  const hasTouch = typeof window !== 'undefined' && 
    ('ontouchstart' in window || 
     navigator.maxTouchPoints > 0 || 
     (navigator as any).msMaxTouchPoints > 0);
     
  // Third check screen size as last resort
  const hasSmallScreen = typeof window !== 'undefined' && 
    window.innerWidth < 768;
    
  return isMobileDevice || (hasTouch && hasSmallScreen);
};

const isMobile = detectMobilePlatform();

// Create a resilient storage system with multiple fallbacks
const createResilientStorage = () => {
  let inMemoryStorage: Record<string, string> = {};
  
  // Function to detect if a storage system works
  const testStorage = (storage: Storage): boolean => {
    try {
      const test = '__storage_test__';
      storage.setItem(test, test);
      const result = storage.getItem(test) === test;
      storage.removeItem(test);
      return result;
    } catch (e) {
      return false;
    }
  };
  
  // Check available storage options
  const hasLocalStorage = typeof localStorage !== 'undefined' && testStorage(localStorage);
  const hasSessionStorage = typeof sessionStorage !== 'undefined' && testStorage(sessionStorage);
  
  // Create a resilient storage interface
  const storage = {
    getItem: (key: string): string | null => {
      // Try all storage options in order of preference
      
      if (hasLocalStorage) {
        try {
          const value = localStorage.getItem(key);
          if (value !== null) return value;
        } catch (e) {
          console.warn('localStorage access failed:', e);
        }
      }
      
      if (hasSessionStorage) {
        try {
          const value = sessionStorage.getItem(key);
          if (value !== null) return value;
        } catch (e) {
          console.warn('sessionStorage access failed:', e);
        }
      }
      
      // Memory fallback
      return inMemoryStorage[key] || null;
    },
    
    setItem: (key: string, value: string): void => {
      // Always keep a copy in memory for reliability
      inMemoryStorage[key] = value;
      
      // Try to persist to more permanent storage
      if (hasLocalStorage) {
        try {
          localStorage.setItem(key, value);
        } catch (e) {
          console.warn('localStorage set failed:', e);
        }
      }
      
      if (hasSessionStorage && !hasLocalStorage) {
        try {
          sessionStorage.setItem(key, value);
        } catch (e) {
          console.warn('sessionStorage set failed:', e);
        }
      }
      
      // Make available globally as last resort
      if (typeof window !== 'undefined') {
        if (!(window as any).__memoryStorage) {
          (window as any).__memoryStorage = {};
        }
        (window as any).__memoryStorage[key] = value;
      }
    },
    
    removeItem: (key: string): void => {
      // Remove from all storage options
      delete inMemoryStorage[key];
      
      if (hasLocalStorage) {
        try {
          localStorage.removeItem(key);
        } catch (e) {}
      }
      
      if (hasSessionStorage) {
        try {
          sessionStorage.removeItem(key);
        } catch (e) {}
      }
      
      if (typeof window !== 'undefined' && (window as any).__memoryStorage) {
        delete (window as any).__memoryStorage[key];
      }
    }
  };
  
  return storage;
};

// Use our enhanced resilient storage adapter
const storageAdapter = createResilientStorage();

// Log connection info to help with debugging
console.log('Supabase client initialization:', {
  isMobile,
  userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown',
  connection: typeof navigator !== 'undefined' && 'connection' in navigator ? 
    (navigator as any).connection?.effectiveType : 'unknown',
  online: typeof navigator !== 'undefined' ? navigator.onLine : true
});

// Create and export the Supabase client with mobile-friendly config
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: storageAdapter,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'pkce', // Better for mobile browsers
    debug: isMobile, // Enable debug mode on mobile to catch more issues
    // Increase timeouts for slower mobile connections
    storageKey: 'sb-session-v2'  // Use a different key to avoid conflicts
  },
  global: {
    headers: {
      'x-client-info': `mobile-${isMobile ? 'true' : 'false'}`,
      'x-connection-type': typeof navigator !== 'undefined' && 'connection' in navigator ? 
        String((navigator as any).connection?.effectiveType || 'unknown') : 'unknown'
    },
    // Increase timeouts for mobile connections
    fetch: (url, options) => {
      const timeoutDuration = isMobile ? 60000 : 30000; // 1 minute for mobile, 30s otherwise
      
      const controller = new AbortController();
      const { signal } = controller;
      
      // Create timeout that aborts the fetch
      const timeout = setTimeout(() => {
        controller.abort();
        console.warn('Supabase fetch timeout after', timeoutDuration);
      }, timeoutDuration);
      
      return fetch(url, {
        ...options,
        signal
      }).finally(() => {
        clearTimeout(timeout);
      });
    }
  },
  // Better for mobile connections
  realtime: {
    params: {
      eventsPerSecond: isMobile ? 3 : 10
    }
  }
});

// Export mobile detection helper
export const isMobileClient = isMobile;

// Create helper to check connection status
export const checkConnection = async (): Promise<boolean> => {
  try {
    // Try a lightweight Supabase call to check connection
    const start = Date.now();
    const { data, error } = await supabase.from('profiles').select('id').limit(1).maybeSingle();
    const end = Date.now();
    console.log(`Connection check took ${end - start}ms`, { success: !error, error });
    return !error;
  } catch (e) {
    console.error('Connection check failed:', e);
    return false;
  }
};
